// src/controllers/userController.ts
import { Request, Response, NextFunction } from "express";
import { userRepository } from "../repository/user.repository";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import {
  logger,
  HttpStatusCodes,
  HttpResponseMessages,
  ErrorMessageCodes,
  sendResponse,
} from "shared-constants";
import { IUser } from "../interfaces/User.interface";

// Register a new user
export const register = async (req: Request, res: Response): Promise<void> => {
  try {
    const { firstName, lastName, email, password } = req.body;

    // Hash Password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Check if user already exists
    const existingUser = await userRepository.findOne({ where: { email } });
    if (existingUser) {
      logger.error("Registration failed: Email already in use");
      sendResponse({
        statusCode: HttpStatusCodes.BAD_REQUEST,
        res,
        message: HttpResponseMessages.BAD_REQUEST,
      });
      return;
    }

    // Create & Save User
    const user: IUser = userRepository.create({
      firstName,
      lastName,
      email,
      password: hashedPassword,
    });

    await userRepository.save(user);
    let userData: IUser = {
      id: user.id,
      firstName: user.firstName,
      lastName: user.lastName,
      email: user.email,
    };
    logger.info("User Created Successfully");
    sendResponse({
      statusCode: HttpStatusCodes.CREATED,
      res,
      message: HttpResponseMessages.CREATED,
      data: userData,
    });
  } catch (err) {
    logger.error("Error while creating user");
    sendResponse({
      statusCode: HttpStatusCodes.INTERNAL_SERVER_ERROR,
      res,
      message: ErrorMessageCodes.INTERNAL_SERVER_ERROR,
      error: err,
    });
    return;
  }
};

// Login an existing user
export const login = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email, password } = req.body;

    // Find User
    const user = await userRepository.findOne({ where: { email } });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      logger.warn("Login attempt failed: Invalid credentials");
      sendResponse({
        statusCode: HttpStatusCodes.UNAUTHORIZED,
        res,
        message: HttpResponseMessages.UNAUTHORIZED,
      });
      return;
    }

    // Ensure JWT Secret is available
    if (!process.env.JWT_SECRET) {
      logger.error("JWT Secret key is not defined");
      throw new Error("Secret key is not defined");
    }

    // Generate JWT Token
    const token = jwt.sign(
      { id: user.id, email: user.email, name: user.firstName },
      process.env.JWT_SECRET,
      {
        expiresIn: "24h",
      }
    );
    let userData = {
      id: user.id,
      firstName: user.firstName,
      lastName: user.lastName,
      email: user.email,
      token,
    };
    logger.info("User logged in successfully...");
    sendResponse({
      statusCode: HttpStatusCodes.OK,
      res,
      message: HttpResponseMessages.SUCCESS,
      data: userData,
    });
  } catch (err) {
    logger.error("Error while logging in user");
    sendResponse({
      statusCode: HttpStatusCodes.INTERNAL_SERVER_ERROR,
      res,
      message: ErrorMessageCodes.INTERNAL_SERVER_ERROR,
      error: err,
    });
    return;
  }
};

export const logout = async (req: Request, res: Response): Promise<void> => {
  try {
    // Frontend should handle token removal; backend can use a blacklist approach
    res.status(HttpStatusCodes.OK).json({
      message: "User Logged Out (Token should be removed on client side)",
    });
    return;
  } catch (err) {
    logger.error("Error while logout");
    res.status(500).json({ message: "Internal Server Error" });
    return;
  }
}; // Create Token table whenever someone login the token which generated by with that user id it store it in token table and then while logout first we will compare token from req.body and then checks user id with current logged in user then we will deleted that token logout that user with the help of toke
